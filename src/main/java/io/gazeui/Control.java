//
// Copyright (c) 2019-2020 Rosberg Linhares (rosberglinhares@gmail.com)
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
//

package io.gazeui;

import java.util.Optional;

public abstract class Control implements Cloneable {
    
    private ContainerControl<?> parent;
    private WebPage page;
    // An ID is necessary to link the client control that raised some event to your underlying
    // server object. This ID is autogenerated when the control is added to some WebPage. Another
    // strategy could be generate the ID in the render method, but this would be another step that
    // could overload the render process.
    private String clientId;
    
    public Optional<ContainerControl<?>> getParent() {
        return Optional.ofNullable(this.parent);
    }
    
    public Optional<WebPage> getPage() {
        if (this.page == null) {
            Optional<? extends Control> control = Optional.of(this);
            
            while (control.filter(c -> !(c instanceof WebPage)).isPresent()) {
                control = control.get().getParent();
            }
            
            this.page = (WebPage)control.orElse(null);
        }
        
        return Optional.ofNullable(this.page);
    }
    
    public Optional<Window> getWindow() {
        return this.getPage()
                .flatMap(page -> page.getParent())
                .map(parent -> (Window)parent);
    }
    
    public Optional<String> getClientId() {
        return Optional.ofNullable(this.clientId);
    }
    
    void onAddToCollection(ContainerControl<?> parent) {
        boolean isControlWithoutPage = !this.getPage().isPresent();
        
        // Remove the new control from its old parent (if any)
        this.getParent().ifPresent(oldParent -> {
            // The remove method will call onBeforeRemoveFromCollection
            oldParent.getControls().remove(this);
        });
        
        this.parent = parent;
        
        if (this.getPage().isPresent() && isControlWithoutPage) {
            // When a control gain a WebPage, we must set the ID of the control and all its descendants
            this.setControlTreeIds(this);
        }
    }
    
    private void setControlTreeIds(Control control) {
        // For controls that were removed from the window and added again:
        //
        // 1. While the control was without a window, another controls could be added to its tree,
        //    so they will not have a client ID. Because of this, we need to traverse all the tree
        //    to reach these controls.
        //
        // 2. The control ID will be preserved.
        if (!control.getClientId().isPresent()){
            control.clientId = this.getPage().get().generateAutomaticControlId();
        }
        
        if (control instanceof ContainerControl) {
            for (Control childControl : ((ContainerControl<?>)control).getControls()) {
                this.setControlTreeIds(childControl);
            }
        }
    }
    
    void onRemoveFromCollection() {
        this.parent = null;
        this.detachControlTree(this);
    }
    
    private void detachControlTree(Control control) {
        // Remove the cached value
        control.page = null;
        
        if (control instanceof ContainerControl) {
            for (Control childControl : ((ContainerControl<?>)control).getControls()) {
                this.detachControlTree(childControl);
            }
        }
    }
    
    @Override
    protected Control clone() {
        // This method is only to make the clone method visible for classes in the same package.
        // This will allow the ContainerControl to clone your child controls.
        
        try {
            return (Control)super.clone();
        } catch (CloneNotSupportedException ex) {
            // Never happens, once Control is implementing Cloneable. 
            throw new RuntimeException(ex);
        }
    }
    
    @Override
    public String toString() {
        return this.getClientId()
                .map(clientId -> String.format("%s, Id: '%s'", this.getClass().getSimpleName(), clientId))
                .orElseGet(() -> this.getClass().getSimpleName() + "@" + Integer.toHexString(this.hashCode()));
    }
    
    /**
     * A script that can be run to find this control on the client side. After running this script,
     * it is possible to use the token returned by the {@link #identificationToken()} method to
     * reach the control.
     */
    protected String selectionScript() {
        return String.format("let %1$s = document.getElementById('%1$s');\n", this.getClientId().get());
    }
    
    /**
     * A token that can be used to reach this control on the client side. This token can be used
     * after running the control's rendering script or after running the script returned by the
     * {@link #selectionScript()} method.
     */
    protected String identificationToken() {
        return this.getClientId().get();
    }
    
    protected abstract void renderCreation(RenderScriptWriter writer);
    protected abstract void renderUpdate(RenderScriptWriter writer, Control previousControlState);
}